"""


목표: 최대로 많이 방문할 수 있는 최댓값을 구하는 것
이동방식:
    1. 2칸 위로, 1칸 오른쪽
    2. 1칸 위로, 2칸 오른쪽
    3. 1칸 아래로, 2칸 오른쪽
    4. 2칸 아래로, 1칸 오른쪽

이동방식 제약:
    1번,4번: N이 3 이상이고 M이 2 이상일 때 사용 가능
    2번,3번: N이 2 이상이고 M이 3 이상일 때 사용 가능

특징:
    1) 1-4번의 특징이 상하좌우에서 '좌'만 없다.
    2) 모든 이동방식에 오른쪽은 꼭 끼어있다.
    위의 두 이유 때문에 빙빙 도는 일 없이 무조건 체스판의 종점에 도착하게 된다.

제약:
- 이동횟수가 4번보다 적다면 움직임에 제약이 업음
- 이동횟수가 4번보다 적지 않다면 꼭 이동방식 4개를 최소 한번씩은 사용을 해야 함
    -따라서 5칸 이상을 가려면 M이 최소 7은 되야 함 (오른쪽을 다 쓰려면 1+2+2+1=6이고 시작 위치가 1이기 때문)

미리 거를 수 있는 조건:
- N이 1일 떄, 최소 한 칸은 위로든 아래로든 가야하기 때문에, 최대 방문 가능 횟수는 현 위치인 1칸
- N이 2일 떄. 2,3을 번갈아 사용하면서 오른쪽으로 2칸 씩 갈 수는 있지만, 1,4번을 사용 못하기 때문에 최대 방문 횟수는 4 미만. 따라서 4랑 (M+1)//2 중 더 작은 값을 출력
    - (M+1)//2인 이유: 1은 시작 지점이라서 더해준거고. 2번 3번 중 뭘 택하더라도 오른쪽으로 2칸씩밖에 못 가서 2를 나눠준것
- M이 1일 떄, 최소 한 칸은 오른쪽으로 가야하기 때문에, 최대 방문 가능 횟수는 현 위치인 1칸
- M이 6과 같거나 작을 때, 만약 5번 이상을 가려면 M=7일때만 가능하기 때문에 무조건 4 이하의 값이 나온다. 따라서 4랑 M 중 더 작은 값을 출력
- M이 6보다 클 때, 위에서 조건들이 걸러지면서 N이 3 이상이라는 거는 보장된 상태라서 오른쪽으로 가는 것만 고려하면 된다.
    다만, 최댓값을 구하려고 하되, 4를 넘기기 위해 모든 경우의 수는 사용해야 해서, 2와 3은 한번씩만 실행하고, 나머지는 오른쪽을 1칸만 가도록 한다. 
    결국 최대 방문 가능 횟수는 M- 2(이동방식 2번의 오른쪽 2칸+ 이동방식 3번의 오른쪽 2칸)


"""
N,M = map(int,input().split())

if N==1 or M==1:
    print(1)
elif N==2:
    print(min(4,(M+1)//2))
elif M<=6:
    print(min(4,M))
else:
    print(M-2)

